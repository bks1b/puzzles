#include <iostream>

void permutations(int n, int total, int *result) {
    if (n == 1) {
        result[0] = 1;
        return;
    }
    int *last_result = new int[total * n];
    int last_total = total / n;
    permutations(n - 1, last_total, last_result);
    for (int i = 0; i < last_total; i++)
        for (int j = 0; j < n; j++) {
            int pos = i % 2 ? n - 1 - j : j;
            for (int k = 0; k < n; k++)
                result[(i * n + j) * n + k] = k == pos
                    ? 1
                    : last_result[i * (n - 1) + k - (k > pos)] + 1;
        }
    delete[] last_result;
}

int main() {
    int n;
    std::cin >> n;
    int total = 1;
    for (int i = 1; i <= n; i++) total *= i;
    int *result = new int[total * n];
    permutations(n, total, result);
    std::cout << total << "\n";
    for (int i = 0; i < total; i++)
        for (int k = 0; k < n; k++)
            std::cout << result[i * n + k] << (k < n - 1 ? " " : "\n");
    delete[] result;
    return 0;
}

/*
Given such a sequence of orderings of @n@ members (@1,ldots,n@), we can construct such a sequence of @n+1@ members:
- For the @k@-th ordering (@0=<k<n!@), increment each number in the ordering by @1@, and insert the number @1@ into all @n+1@ possible places.
- If @2 div k@, start before the first element and end after the last element.
- Otherwise, start after the last element and end before the first element.
Proof:
- Exactly two members swap places between the orderings generated from the @k@-th ordering: the number @1@ swaps places with one of its neighbors.
- The last ordering generated by @k@ is followed by an ordering with the number @1@ in the same place, and since we constructed the new orderings from a sufficient sequence of orderings, the rest of the numbers differ by a single swap.
*/